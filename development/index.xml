<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Development on Core Rule Set Documentation</title><link>https://coreruleset.github.io/documentation/development/</link><description>Recent content in Development on Core Rule Set Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://coreruleset.github.io/documentation/development/index.xml" rel="self" type="application/rss+xml"/><item><title>Contribution Guidelines</title><link>https://coreruleset.github.io/documentation/development/contribution_guidelines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/contribution_guidelines/</guid><description>The CRS project values third party contributions. To make the contribution process as easy as possible, a helpful set of contribution guidelines are in place which all contributors and developers are asked to adhere to.
Getting Started with a New Contribution Sign in to GitHub. Open a new issue for the contribution, assuming a similar issue doesn&amp;rsquo;t already exist. Clearly describe the issue, including steps to reproduce if reporting a bug.</description></item><item><title>crs-toolchain</title><link>https://coreruleset.github.io/documentation/development/crs_toolchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/crs_toolchain/</guid><description>The crs-toolchain is the utility belt of CRS developers. It provides a single point of entry and a consistent interface for a range of different tools. Its core functionality (owed to the great rassemble-go, which is itself based on the brain-melting Regexp::Assemble Perl module) is to assemble individual parts of a regular expression into a single expression (with some optimizations).
Setup With Existing Go Environment If a current Go environment is present, simply run</description></item><item><title>Assembling Regular Expressions</title><link>https://coreruleset.github.io/documentation/development/regex_assembly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/regex_assembly/</guid><description>The CRS team uses a custom specification format to specify how a regular expression is to be generated from its components. This format enables reuse across different files, explanation of choices and techniques with comments, and specialized processing.
Specification Format The files containing regular expression specifications (.ra suffix, under regex-assembly) contain one regular expression per line. These files are meant to be processed by the crs-toolchain.
Example The following is an example of what an assembly file might contain:</description></item><item><title>Writing Rules</title><link>https://coreruleset.github.io/documentation/development/rule_writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/rule_writing/</guid><description>From years of experience, the CRS project has assembled a wealth of knowledge and advice on how to write clear and efficient WAF rules, as this page outlines.
The CRS project&amp;rsquo;s advice on rule writing is contained within the contribution guidelines, a document which can also be found in plain text form in CRS releases for offline reference. The guidelines contain invaluable guidance and tips on how to write rules, including:</description></item><item><title>Useful Tools</title><link>https://coreruleset.github.io/documentation/development/useful_tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/useful_tools/</guid><description>There are many first and third party tools that help with ModSecurity and CRS development. The most useful ones are listed here. Get in touch if you think something is missing.
coraza-httpbin https://github.com/jcchavezs/coraza-httpbin
A Coraza plus reverse proxy container for testing. Makes it possible to easily test CRS with Coraza in a similar way to testing CRS using the Apache and Nginx Docker containers.
A local CRS installation can be included using directives in a directives.</description></item><item><title>Testing the Rule Set</title><link>https://coreruleset.github.io/documentation/development/testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/testing/</guid><description>Testing for rule developers Well, you managed to write your rule, but now want to see if if can be added to the CRS? This document should help you to test it using the same tooling the project uses for its tests.
Tests are performed using a Python tool called ftw. We run them using a GitHub actions pipeline. You can easily reproduce that locally, in your workstation.
For that you will need:</description></item><item><title>Writing Plugins</title><link>https://coreruleset.github.io/documentation/development/plugin_writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/plugin_writing/</guid><description>The CRS plugin mechanism allows the rule set to be extended in specific, experimental, or unusual ways. This page explains how to write a new plugin to extend CRS.
How to Write a Plugin Is a Plugin the Right Approach for a Given Rule Problem? This is the first and most important question to ask.
CRS is a generic rule set. The rule set has no awareness of the particular setup it finds itself deployed in.</description></item><item><title>Using the CRS Sandbox</title><link>https://coreruleset.github.io/documentation/development/sandbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/sandbox/</guid><description>Introducing the CRS Sandbox We have set up a public CRS Sandbox which you can use to send attacks at the CRS. You can choose between various WAF engines and CRS versions. The sandbox parses audit logs and returns our detections in an easy and useful format.
The sandbox is useful for:
integrators and administrators: you can test out our response in case of an urgent security event, such as the Log4j vulnerability; exploit developers/researchers: if you have devised a payload, you can test beforehand if it will be blocked by the CRS and by which versions; CRS developers/rule writers: you can quickly check if the CRS catches a (variant of an) exploit without the hassle of setting up your own CRS instance.</description></item></channel></rss>